% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_survival.R
\name{create_survival}
\alias{create_survival}
\title{High-level survival wrapper}
\usage{
create_survival(
  data,
  time_col,
  event_col,
  group_col = "UsageSegments_12w",
  auto_segment_if_missing = TRUE,
  identify_metric = NULL,
  identify_metric_str = NULL,
  identify_version = "12w",
  threshold = NULL,
  width = NULL,
  max_window = NULL,
  power_thres = NULL,
  id_col = "PersonId",
  required_segments = NULL,
  synonyms_map = NULL,
  enforce_required_segments = TRUE,
  mingroup = 5,
  timeline = NULL,
  dropna = TRUE,
  use_survival = TRUE,
  return_type = c("plot", "table"),
  figsize = c(8, 6),
  title = "Survival Curve by Segment",
  subtitle = "Kaplanu2013Meier estimate",
  caption_from_date_range = TRUE,
  caption_text = NULL,
  legend_loc = "upper right",
  legend_bbox_to_anchor = c(1.3, 1.1),
  linewidth = 2,
  missing_draw = c("nan", "one")
)
}
\arguments{
\item{data}{Data frame with time, event, and optional segmentation columns.}

\item{time_col}{Character. Column name for time-to-event.}

\item{event_col}{Character. Column name for event indicator (1=event, 0=censored).}

\item{group_col}{Character or NULL. Group/segment column name (default: "UsageSegments_12w").}

\item{auto_segment_if_missing}{Logical; if TRUE, tries vivainsights::identify_usage_segments() when group_col missing.}

\item{identify_metric}{Single metric name used for auto-segmentation.}

\item{identify_metric_str}{Character vector of metric names to sum for segmentation.}

\item{identify_version}{Version string passed to identify_usage_segments (default "12w").}

\item{threshold, width, max_window, power_thres}{Reserved / passed to identify (optional tuning args).}

\item{id_col}{Character. Person ID column (default: "PersonId").}

\item{required_segments}{Character vector of canonical segments to enforce.}

\item{synonyms_map}{Named vector mapping variants -> canonical labels.}

\item{enforce_required_segments}{Logical; if TRUE, force required segment ordering.}

\item{mingroup}{Minimum unique people to retain a group (default: 5).}

\item{timeline}{Numeric or NULL. Time points for survival evaluation.}

\item{dropna}{Logical. Drop NA time/event rows when TRUE (default TRUE).}

\item{use_survival}{Logical. Reserved for future extension.}

\item{return_type}{"plot" or "table" (default: "plot").}

\item{figsize}{Numeric length-2 for saved figure size.}

\item{title, subtitle, caption_text}{Plot annotation strings.}

\item{caption_from_date_range}{Logical; if TRUE and vivainsights available, append date-range to caption.}

\item{legend_loc}{Legend placement keyword.}

\item{legend_bbox_to_anchor}{Kept for API parity.}

\item{linewidth}{Numeric line width for plot curves.}

\item{missing_draw}{Character. How to draw requested-but-missing groups ("nan" or "one").}
}
\value{
If \code{return_type = "table"}: data.frame with columns (group, time, survival, at_risk, events).
If \code{return_type = "plot"}: ggplot2 object with Kaplanu2013Meier curves.
}
\description{
Compute and return Kaplanu2013Meier survival estimates either as a long-format
table or as a ggplot object. Supports optional auto-segmentation via
vivainsights::identify_usage_segments(), canonicalization of segment labels,
and enforcement of required segment ordering for plotting.
}
\examples{
\dontrun{
pq <- load_pq_data()
# Table output
tbl <- create_survival(pq, time_col = "Days_active", event_col = "Churned", return_type = "table")
# Plot output
p <- create_survival(pq, time_col = "Days_active", event_col = "Churned")
}
}
